//--------------------------------------------------------------
void ofApp::getFlowDirForCell(int gx, int gy, int& dx, int& dy) {
    dx = 0;
    dy = 0;

    // ★ 実際のサイズから行・列数を取得
    int rows = static_cast<int>(flowField.size());
    if (rows == 0) return;
    int cols = static_cast<int>(flowField[0].size());

    if (gx < 0 || gx >= cols || gy < 0 || gy >= rows) return;

    ofVec2f v = flowField[gy][gx];

    const float threshold = 0.25f;

    if (v.x >  threshold) dx =  1;
    else if (v.x < -threshold) dx = -1;

    if (v.y >  threshold) dy =  1;
    else if (v.y < -threshold) dy = -1;
}



//--------------------------------------------------------------
void ofApp::generateFlowFieldForCurrentWeather() {

    int rows = static_cast<int>(flowField.size());
    if (rows == 0) return;
    int cols = static_cast<int>(flowField[0].size());
    if (cols == 0) return;

    float baseNoiseScale = 0.06f;

    for (int y = 0; y < rows; ++y) {
        for (int x = 0; x < cols; ++x) {

            ofVec2f mainDir(0, 0);
            float mainStrength  = 0.0f;
            float noiseStrength = 0.0f;

            switch (currentWeather) {
            case WEATHER_SUNNY:
                mainDir.set(0, 0);
                mainStrength  = 0.0f;
                noiseStrength = 0.2f;
                break;

            case WEATHER_CLOUDY:
                mainDir.set(1.0f, -0.5f);   // 30度くらい斜め
                mainDir.normalize();
                mainStrength  = 0.7f;
                noiseStrength = 0.3f;
                break;

            case WEATHER_RAINY:
                mainDir.set(0.0f, 1.0f);    // 下向き
                mainStrength  = 0.7f;
                noiseStrength = 0.3f;
                break;

            case WEATHER_SNOWY:
                mainDir.set(1.0f, 1.0f);    // 45度
                mainDir.normalize();
                mainStrength  = 0.6f;
                noiseStrength = 0.4f;
                break;

            case WEATHER_THUNDERSTORM:
                mainDir.set(1.0f, -1.0f);   // 斜め上への強風
                mainDir.normalize();
                mainStrength  = 0.5f;
                noiseStrength = 0.5f;
                break;
            }

            float t = ofGetElapsedTimef();
            float nx = ofNoise(x * baseNoiseScale,
                               y * baseNoiseScale,
                               t * 0.4f);
            float ny = ofNoise((x + 1000) * baseNoiseScale,
                               (y + 1000) * baseNoiseScale,
                               t * 0.4f);

            ofVec2f noiseDir(nx - 0.5f, ny - 0.5f);
            if (noiseDir.lengthSquared() > 0.0001f) {
                noiseDir.normalize();
            }

            ofVec2f v = mainDir * mainStrength + noiseDir * noiseStrength;
            if (v.lengthSquared() > 0.0001f) {
                v.normalize();
            }

            flowField[y][x] = v;
        }
    }
}




//--------------------------------------------------------------
void ofApp::updateCA() {
    int rows = static_cast<int>(ca.size());
    if (rows == 0) return;
    int cols = static_cast<int>(ca[0].size());
    if (cols == 0) return;

    // caNext / caHP のサイズも念のため合わせる
    if ((int)caNext.size() != rows || (int)caNext[0].size() != cols) {
        caNext.assign(rows, vector<int>(cols, 0));
    }
    if ((int)caHP.size() != rows || (int)caHP[0].size() != cols) {
        caHP.assign(rows, vector<int>(cols, 0));
    }

    // ---------- 1. B3/S23 ----------
    for (int y = 0; y < rows; ++y) {
        for (int x = 0; x < cols; ++x) {

            int aliveNeighbors = 0;

            for (int j = -1; j <= 1; ++j) {
                for (int i = -1; i <= 1; ++i) {
                    if (i == 0 && j == 0) continue;

                    int nx = (x + i + cols) % cols;
                    int ny = (y + j + rows) % rows;

                    aliveNeighbors += ca[ny][nx];
                }
            }

            int current   = ca[y][x];
            int nextState = 0;

            if (current == 1) {
                if (aliveNeighbors == 2 || aliveNeighbors == 3) {
                    nextState = 1;
                } else {
                    nextState = 0;
                }
            } else {
                if (aliveNeighbors == 3) {
                    nextState = 1;
                } else {
                    nextState = 0;
                }
            }

            if (nextState == 0 && aliveNeighbors == 0) {
                if (ofRandom(1.0f) < 0.001f) {
                    nextState = 1;
                }
            }

            caNext[y][x] = nextState;
        }
    }

    // ---------- 2. ベクトル場 + 勝者ルール + HP ----------
    vector<vector<int>> moved(rows, vector<int>(cols, 0));
    vector<vector<int>> newHP(rows, vector<int>(cols, 0));

    for (int y = 0; y < rows; ++y) {
        for (int x = 0; x < cols; ++x) {

            if (caNext[y][x] != 1) continue;

            int dx = 0, dy = 0;
            getFlowDirForCell(x, y, dx, dy);

            int tx = (x + dx + cols) % cols;
            int ty = (y + dy + rows) % rows;

            int oldHP = caHP[y][x];
            if (oldHP <= 0) oldHP = 1;

            if (moved[ty][tx] == 0) {
                moved[ty][tx]  = 1;
                newHP[ty][tx]  = std::min(oldHP + 1, maxHP);
            } else {
                if (ofRandom(1.0f) < 0.5f) {
                    moved[ty][tx] = 1;
                    newHP[ty][tx] = std::min(oldHP + 1, maxHP);
                } else {
                    newHP[ty][tx] = std::min(newHP[ty][tx] + 1, maxHP);
                }
            }
        }
    }

    // ---------- 3. スカスカ領域に種を撒く ----------
    int aliveCount = 0;
    for (int y = 0; y < rows; ++y)
        for (int x = 0; x < cols; ++x)
            if (moved[y][x] == 1) aliveCount++;

    int totalCells = rows * cols;
    int minAlive   = static_cast<int>(totalCells * 0.02f);

    if (aliveCount < minAlive) {
        int seedCount = 5;
        for (int s = 0; s < seedCount; ++s) {
            int rx = static_cast<int>(ofRandom(cols));
            int ry = static_cast<int>(ofRandom(rows));
            moved[ry][rx] = 1;
            newHP[ry][rx] = 1;
        }
    }

    ca   = moved;
    caHP = newHP;
}




//--------------------------------------------------------------
void ofApp::updateCloudCA() {
    int rows = static_cast<int>(cloudCA.size());
    if (rows == 0) return;
    int cols = static_cast<int>(cloudCA[0].size());
    if (cols == 0) return;

    // 念のため ca と同じかチェック
    int caRowsNow = static_cast<int>(ca.size());
    int caColsNow = caRowsNow > 0 ? static_cast<int>(ca[0].size()) : 0;

    if (rows != caRowsNow || cols != caColsNow) {
        cloudCA.assign(caRowsNow, vector<int>(caColsNow, 0));
        rows = caRowsNow;
        cols = caColsNow;
        if (rows == 0 || cols == 0) return;
    }

    for (int y = 0; y < rows; ++y) {
        for (int x = 0; x < cols; ++x) {
            if (ca[y][x] == 1) {
                cloudCA[y][x] = 3;
            } else {
                if (cloudCA[y][x] > 0) cloudCA[y][x]--;
            }
        }
    }
}




//--------------------------------------------------------------
void ofApp::drawCA() {

    int rows = static_cast<int>(ca.size());
    if (rows == 0) return;
    int cols = static_cast<int>(ca[0].size());
    if (cols == 0) return;

    for (int y = 0; y < rows; ++y) {
        for (int x = 0; x < cols; ++x) {

            if (ca[y][x] == 0) continue;

            float cx = x * cellSize + cellSize * 0.5f;
            float cy = y * cellSize + cellSize * 0.5f;
            float baseR = cellSize * 0.45f;

            ofColor baseColor;
            switch (currentWeather) {
            case WEATHER_SUNNY:        baseColor = ofColor(255,240,150); break;
            case WEATHER_CLOUDY:       baseColor = ofColor(190,190,210); break;
            case WEATHER_RAINY:        baseColor = ofColor(100,140,255); break;
            case WEATHER_SNOWY:        baseColor = ofColor(230,250,255); break;
            case WEATHER_THUNDERSTORM: baseColor = ofColor(255,230,80);  break;
            default:                   baseColor = ofColor(255);         break;
            }

            int hp = (int)caHP.size() > y && (int)caHP[y].size() > x ? caHP[y][x] : 1;
            if (hp <= 0) hp = 1;
            int rings = hp;

            float radius = baseR;

            for (int k = 0; k < rings; ++k) {

                float t = (float)k / (float)rings;
                ofColor c = baseColor;
                c.lerp(ofColor::white, t * 0.5f);
                ofSetColor(c);

                float r = radius;

                switch (currentWeather) {
                case WEATHER_SUNNY:
                    ofNoFill();
                    ofDrawCircle(cx, cy, r);
                    ofFill();
                    break;

                case WEATHER_THUNDERSTORM:
                    ofNoFill();
                    ofDrawTriangle(
                        cx,     cy - r,
                        cx - r, cy + r,
                        cx + r, cy + r
                    );
                    ofFill();
                    break;

                case WEATHER_CLOUDY:
                {
                    float w0 = r * 3.0f;
                    float h0 = r * 1.6f;
                    float skew = w0 * 0.3f;
                    ofNoFill();
                    ofDrawLine(cx - w0/2 + skew, cy - h0/2,
                               cx + w0/2 + skew, cy - h0/2);
                    ofDrawLine(cx + w0/2 + skew, cy - h0/2,
                               cx + w0/2 - skew, cy + h0/2);
                    ofDrawLine(cx + w0/2 - skew, cy + h0/2,
                               cx - w0/2 - skew, cy + h0/2);
                    ofDrawLine(cx - w0/2 - skew, cy + h0/2,
                               cx - w0/2 + skew, cy - h0/2);
                    ofFill();
                }
                break;

                case WEATHER_RAINY:
                    ofNoFill();
                    ofDrawLine(cx,     cy - r, cx + r, cy);
                    ofDrawLine(cx + r, cy,     cx,     cy + r);
                    ofDrawLine(cx,     cy + r, cx - r, cy);
                    ofDrawLine(cx - r, cy,     cx,     cy - r);
                    ofFill();
                    break;

                case WEATHER_SNOWY:
                {
                    ofNoFill();
                    ofPolyline poly;
                    for (int i = 0; i < 6; ++i) {
                        float angle = TWO_PI * i / 6.0f;
                        poly.addVertex(cx + cos(angle)*r,
                                       cy + sin(angle)*r);
                    }
                    poly.close();
                    poly.draw();
                    ofFill();
                }
                break;
                }

                radius *= 0.8f;
                if (radius < 1.0f) break;
            }
        }
    }
}




//--------------------------------------------------------------
void ofApp::drawCloudCA() {

    int rows = static_cast<int>(cloudCA.size());
    if (rows == 0) return;
    int cols = static_cast<int>(cloudCA[0].size());
    if (cols == 0) return;

    for (int y = 0; y < rows; ++y) {
        for (int x = 0; x < cols; ++x) {

            int v = cloudCA[y][x];
            if (v <= 0) continue;

            float cx = x * cellSize + cellSize * 0.5f;
            float cy = y * cellSize + cellSize * 0.5f;
            float r  = cellSize * 0.2f;

            int alpha = v * 60;
            ofSetColor(255, 255, 255, alpha);
            ofDrawCircle(cx, cy, r);
        }
    }
}



