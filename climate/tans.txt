## tarans for


void ofApp::update() {
    float dt = ofGetLastFrameTime();

    // === 天候ごとの CA 更新スピード ===
    switch (currentWeather) {
    case WEATHER_SUNNY:
        caUpdateInterval    = 0.25f;  // 一番ゆっくり
        cloudUpdateInterval = 0.35f;
        break;

    case WEATHER_CLOUDY:
        caUpdateInterval    = 0.20f;  // 晴れより少し速い
        cloudUpdateInterval = 0.30f;
        break;

    case WEATHER_RAINY:
        caUpdateInterval    = 0.14f;  // さらに速い
        cloudUpdateInterval = 0.24f;
        break;

    case WEATHER_SNOWY:
        caUpdateInterval    = 0.18f;  // 曇りと雨の中間
        cloudUpdateInterval = 0.28f;
        break;

    case WEATHER_THUNDERSTORM:
        caUpdateInterval    = 0.10f;  // 一番速い
        cloudUpdateInterval = 0.20f;
        break;
    }

    // ベクトル場の時間（風の進み）はそのまま
    flowTime += dt;

    // === 天気 CA の時間管理 ===
    caTimer += dt;
    if (caTimer >= caUpdateInterval) {
        updateCA();
        caTimer = 0.0f;
    }

    // === 雲 CA の時間管理 ===
    cloudTimer += dt;
    if (cloudTimer >= cloudUpdateInterval) {
        updateCloudCA();
        cloudTimer = 0.0f;
    }

    // === カオスで天気を揺らがせる ===
    weatherTimer += dt;
    updateWeatherByChaos();
}


//--------------------------------------------------------------
// 天気 CA 更新（トーラス境界、死んだセルから雲 CA を生む）
//
// ・ルールは全天候で共通：標準ライフゲーム B3/S23
// ・完全停止を防ぐために、ほんの少しだけランダム誕生ノイズを入れる
//   → 「できるだけ動き続ける」ための仕掛け
void ofApp::updateCA() {

    // 停止回避用のランダム誕生確率（必要なら 0.0f にしてOFFにもできる）
    const float randomBirthProb = 0.005f; // 0.5% くらい

    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {

            int current = ca[y][x];

            // 8近傍の生存セル数（トーラス境界）
            int aliveNeighbors = 0;
            for (int j = -1; j <= 1; j++) {
                for (int i = -1; i <= 1; i++) {
                    if (i == 0 && j == 0) continue; // 自分自身は含めない

                    int nx = (x + i + caCols) % caCols;
                    int ny = (y + j + caRows) % caRows;

                    aliveNeighbors += ca[ny][nx];
                }
            }

            int nextState = current;

            // --- 基本ルール：B3 / S23 (Game of Life) ---
            if (current == 1) {
                // 生きているセル：近傍 2 or 3 で生存
                if (aliveNeighbors == 2 || aliveNeighbors == 3) {
                    nextState = 1;
                } else {
                    nextState = 0;
                }
            } else {
                // 死んでいるセル：近傍 3 で誕生
                if (aliveNeighbors == 3) {
                    nextState = 1;
                } else {
                    nextState = 0;
                }

                // ★ 停止回避用のノイズ：
                //    近傍が少ない場所で、ごくたまにランダム誕生させる。
                if (nextState == 0 && aliveNeighbors == 0) {
                    float r = ofRandom(1.0f);
                    if (r < randomBirthProb) {
                        nextState = 1;
                    }
                }
            }

            // 「今まで生きていたのに次フレームで死ぬセル」から雲 CA を誕生させる
            if (current == 1 && nextState == 0) {
                cloudCA[y][x] = 1;
            }

            caNext[y][x] = nextState;
        }
    }

    ca = caNext;
}




