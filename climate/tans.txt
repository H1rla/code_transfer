//--------------------------------------------------------------
void ofApp::drawCA() {

    int w = ofGetWidth();
    int h = ofGetHeight();

    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {

            if (ca[y][x] == 0) continue;

            float baseX = x * cellSize + cellSize * 0.5f;
            float baseY = y * cellSize + cellSize * 0.5f;

            ofVec2f v = flowField[y][x];
            float cx = baseX + v.x * flowTime;
            float cy = baseY + v.y * flowTime;

            // wrap
            if (w > 0) {
                cx = fmodf(cx, (float)w);
                if (cx < 0) cx += w;
            }
            if (h > 0) {
                cy = fmodf(cy, (float)h);
                if (cy < 0) cy += h;
            }

            float baseR = cellSize * 0.45f;

            // -------------------------
            // 天候ごとの色
            // -------------------------
            ofColor baseColor;
            switch (currentWeather) {
            case WEATHER_SUNNY:        baseColor = ofColor(255,240,150); break;
            case WEATHER_CLOUDY:       baseColor = ofColor(190,190,210); break;
            case WEATHER_RAINY:        baseColor = ofColor(100,140,255); break;
            case WEATHER_SNOWY:        baseColor = ofColor(230,250,255); break;
            case WEATHER_THUNDERSTORM: baseColor = ofColor(255,230,80); break;
            default:                   baseColor = ofColor(255); break;
            }

            // -------------------------
            // レベル取得
            // -------------------------
            int lvl = caLevel[y][x];
            if (lvl <= 0) lvl = 1;

            // =====================================================
            // 多重化ブロック（天気ごとに基礎形だけ変わる）
            // =====================================================

            float radius = baseR;

            for (int k = 0; k < lvl; k++) {

                float t = (float)k / (float)lvl;
                ofColor cc = baseColor;
                cc.lerp(ofColor::white, t * 0.5f);
                ofSetColor(cc);

                float r = radius;

                // -------------------------------------------------
                // 晴れ：円
                // -------------------------------------------------
                if (currentWeather == WEATHER_SUNNY) {
                    ofNoFill();
                    ofDrawCircle(cx, cy, r);
                    ofFill();
                }

                // -------------------------------------------------
                // 雷：三角
                // -------------------------------------------------
                else if (currentWeather == WEATHER_THUNDERSTORM) {

                    ofNoFill();
                    ofDrawTriangle(
                        cx, cy - r,
                        cx - r, cy + r,
                        cx + r, cy + r
                    );
                    ofFill();
                }

                // -------------------------------------------------
                // 曇り：平行四辺形
                // -------------------------------------------------
                else if (currentWeather == WEATHER_CLOUDY) {

                    float w0 = r * 3.0f;
                    float h0 = r * 1.6f;
                    float skew = w0 * 0.3f;

                    ofNoFill();
                    ofDrawLine(cx - w0/2 + skew, cy - h0/2, cx + w0/2 + skew, cy - h0/2);
                    ofDrawLine(cx + w0/2 + skew, cy - h0/2, cx + w0/2 - skew, cy + h0/2);
                    ofDrawLine(cx + w0/2 - skew, cy + h0/2, cx - w0/2 - skew, cy + h0/2);
                    ofDrawLine(cx - w0/2 - skew, cy + h0/2, cx - w0/2 + skew, cy - h0/2);
                    ofFill();
                }

                // -------------------------------------------------
                // 雨：菱形（ダイヤ）
                // -------------------------------------------------
                else if (currentWeather == WEATHER_RAINY) {

                    ofNoFill();
                    ofDrawLine(cx,     cy - r,  cx + r, cy);
                    ofDrawLine(cx + r, cy,      cx,     cy + r);
                    ofDrawLine(cx,     cy + r,  cx - r, cy);
                    ofDrawLine(cx - r, cy,      cx,     cy - r);
                    ofFill();
                }

                // -------------------------------------------------
                // 雪：六角形
                // -------------------------------------------------
                else if (currentWeather == WEATHER_SNOWY) {

                    ofNoFill();
                    ofPolyline poly;
                    for (int i = 0; i < 6; i++) {
                        float angle = TWO_PI * i / 6.0f;
                        poly.addVertex(cx + cos(angle)*r, cy + sin(angle)*r);
                    }
                    poly.close();
                    poly.draw();
                    ofFill();
                }

                // 縮小して次（内側）を描く
                radius *= 0.8f;
                if (radius < 1.0f) break;
            }
        }
    }
}