#pragma once

#include "ofMain.h"
#include <vector>
#include <algorithm>

using std::vector;

// 天気の種類
enum WeatherType {
    WEATHER_SUNNY = 0,
    WEATHER_CLOUDY,
    WEATHER_RAINY,
    WEATHER_SNOWY,
    WEATHER_THUNDERSTORM
};

class ofApp : public ofBaseApp {
public:
    void setup() override;
    void update() override;
    void draw() override;
    void keyPressed(int key) override;

private:
    // === 現在の天気 ===
    WeatherType currentWeather;

    // === セルオートマトン共通 ===
    int cellSize;
    int caCols;
    int caRows;

    // 天候 CA（主役）
    vector<vector<int>> ca;      // 現在の生死
    vector<vector<int>> caNext;  // B3/S23 計算用

    // HP（勝者レベルとして扱う） 0〜maxHP
    vector<vector<int>> caHP;
    int maxHP;

    float caUpdateInterval;
    float caTimer;

    // === 雲 CA（残光的な雲） ===
    vector<vector<int>> cloudCA;
    float cloudUpdateInterval;
    float cloudTimer;

    // === ベクトル場（天候による風の向き） ===
    vector<vector<ofVec2f>> flowField;
    float flowTime; // ノイズ時間として使用

    // === 天候の周期的切り替え（テスト用） ===
    float weatherChangeTimer;
    float weatherChangeInterval; // 例: 10秒ごとに変更

    // ---------- 内部関数 ----------
    void randomizeCA();

    // 天候 CA の更新
    void updateCA();

    // 雲 CA の更新（残光）
    void updateCloudCA();

    // 描画
    void drawCA();
    void drawCloudCA();

    // ベクトル場生成（モデルC：天候方向 + ノイズ揺らぎ）
    void generateFlowFieldForCurrentWeather();

    // ベクトル場の時間変化（ここでは毎フレーム再生成する）
    void updateFlowFieldOverTime();

    // グリッド座標 (gx, gy) に対して flowField から整数方向 (dx, dy) を得る
    void getFlowDirForCell(int gx, int gy, int& dx, int& dy);
};