if (movedGrid[y][x] == 1) {
    // ★ 勝者：無限に多重化する
    int lvl = caLevel[y][x];
    if (lvl <= 0) lvl = 1;
    else lvl += 1;          // 無限増殖
    caLevel[y][x] = lvl;
} else {
    // ★ 負けたら完全削除
    caLevel[y][x] = 0;
}


ofNoFill();
ofDrawCircle(cx, cy, r);
ofFill();



ofNoFill();
ofDrawTriangle(
    cx, cy - r,
    cx - r, cy + r,
    cx + r, cy + r
);
ofFill();




case WEATHER_SUNNY:
{
    int lvl = caLevel[y][x];
    if (lvl <= 0) break;

    float radius = baseR;

    ofColor c = baseColor;

    for (int k = 0; k < lvl; k++) {

        // 色：内側ほど白く
        float t = (float)k / (float)lvl;
        ofColor cc = c;
        cc.lerp(ofColor::white, t * 0.5f);
        ofSetColor(cc);

        // 枠線で描く
        ofNoFill();
        ofDrawCircle(cx, cy, radius);
        ofFill();

        radius *= 0.8f;      // ← 0.8 倍で縮小して中に積層
        if (radius < 1.0f) break;
    }
}
break;



case WEATHER_THUNDERSTORM:
{
    int lvl = caLevel[y][x];
    if (lvl <= 0) break;

    float radius = baseR;

    for (int k = 0; k < lvl; k++) {

        float t = (float)k / (float)lvl;
        ofColor cc = baseColor;
        cc.lerp(ofColor::white, t * 0.5f);
        ofSetColor(cc);

        float r = radius;

        ofNoFill();
        ofDrawTriangle(
            cx, cy - r,
            cx - r, cy + r,
            cx + r, cy + r
        );
        ofFill();

        radius *= 0.8f;
        if (radius < 1.0f) break;
    }
}
break;


