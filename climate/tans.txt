#pragma once

#include "ofMain.h"
using std::vector;

// 天気の種類
enum WeatherType {
    WEATHER_SUNNY,
    WEATHER_CLOUDY,
    WEATHER_RAINY,
    WEATHER_SNOWY,
    WEATHER_THUNDERSTORM,
};

class ofApp : public ofBaseApp {
public:
    void setup();
    void update();
    void draw();
    void keyPressed(int key);

private:
    // === 現在の天気 ===
    WeatherType currentWeather;

    // === セルオートマトン共通 ===
    int cellSize;
    int caCols;
    int caRows;

    // === 天気用セルオートマトン ===
    vector<vector<int>> ca;
    vector<vector<int>> caNext;
    float caUpdateInterval;
    float caTimer;

    void randomizeCA();
    void updateCA();
    void drawCA();

    // === 雲用セルオートマトン ===
    vector<vector<int>> cloudCA;
    vector<vector<int>> cloudNext;
    float cloudUpdateInterval;
    float cloudTimer;

    void updateCloudCA();
    void drawCloudCA();

    // === ベクトル場（天候による風の向き・速さ） ===
    // CA グリッドと同じサイズで、各セルに速度ベクトルを持つ
    vector<vector<ofVec2f>> flowField;
    // 経過時間（ベクトル場は静的、時間だけ進める）
    float flowTime;

    // 現在の天気に応じて flowField を生成し直す
    void generateFlowFieldForCurrentWeather();

    // === 天気カオス制御 ===
    double chaosX;          // ロジスティック写像の現在値 (0〜1)
    double chaosR;          // カオスのパラメータ (3.8〜4.0あたり)
    float  weatherTimer;    // 天気切り替え用タイマー
    float  weatherBaseMin;  // 天気が変わる最小間隔（秒）
    float  weatherBaseMax;  // 天気が変わる最大間隔（秒）

    void stepChaos();              // chaosX を1ステップ進める
    void updateWeatherByChaos();   // タイミング＋方向を決めて天気を変える
    void applyWeatherStep(int step, bool forceThunder); // 進む/戻る/スキップ/雷

    // === 雲のブロブ描画（量子表示） ===
    void drawCloudBlob(float cx, float cy,
        float baseR,
        const ofColor& baseColor,
        float seed);

    // オプション：ノイズ多角形（今は使っても使わなくてもOK）
    void drawNoisyPolygon(float cx, float cy,
        float baseRadius,
        int sides,
        float rotationRad,
        float noiseScale,
        float noiseAmp,
        float seed,
        float time);

    // グリッド座標 (gx,gy) に対して、天候ごとの整数ベクトル方向 (dx,dy) を返す
    void getFlowDirForCell(int gx, int gy, int& dx, int& dy);
};





#include "ofApp.h"
#include <cmath>

//--------------------------------------------------------------
void ofApp::setup() {
    ofSetBackgroundColor(0);
    currentWeather = WEATHER_SUNNY;

    // === セルオートマトン初期化 ===
    cellSize = 20;
    caCols = ofGetWidth() / cellSize;
    caRows = ofGetHeight() / cellSize;

    ca.assign(caRows, vector<int>(caCols, 0));
    caNext.assign(caRows, vector<int>(caCols, 0));
    randomizeCA();

    caUpdateInterval = 0.2f;
    caTimer = 0.0f;

    // === 雲用 CA 初期化 ===
    cloudCA.assign(caRows, vector<int>(caCols, 0));
    cloudNext.assign(caRows, vector<int>(caCols, 0));
    cloudUpdateInterval = 0.30f;
    cloudTimer = 0.0f;

    // === ベクトル場初期化 ===
    flowField.assign(caRows, vector<ofVec2f>(caCols, ofVec2f(0, 0)));
    flowTime = 0.0f;
    generateFlowFieldForCurrentWeather();

    // === 天気カオス制御の初期化 ===
    chaosR = 3.9;                       // カオス度合い
    chaosX = ofRandom(0.1, 0.9);        // 初期値 (0,1) の間でランダム
    weatherTimer = 0.0f;
    weatherBaseMin = 5.0f;              // 最短 5 秒ごとに天気が変わる
    weatherBaseMax = 25.0f;             // 最長 25 秒くらい変わらない
}

//--------------------------------------------------------------
// 現在の天気に応じてベクトル場を生成（バンドごとに方向をランダム）
void ofApp::generateFlowFieldForCurrentWeather() {
    flowTime = 0.0f;  // 天気が変わるたびに時間もリセット

    flowField.assign(caRows, vector<ofVec2f>(caCols, ofVec2f(0, 0)));

    // 晴れはベクトル場なし（全部0のまま）
    if (currentWeather == WEATHER_SUNNY) {
        return;
    }

    // バンドの分割数
    int bandRows = 1;
    int bandCols = 1;
    float baseSpeed = 20.0f;  // px/sec くらいの基準速度

    // 小さなヘルパー：±1 を返す
    auto randomSign = []() -> float {
        return (ofRandomuf() < 0.5f) ? -1.0f : 1.0f;
    };

    switch (currentWeather) {
    case WEATHER_CLOUDY:
        // 縦1 × 横4：左右に流れる層
        bandRows = 1;
        bandCols = 4;
        baseSpeed = 25.0f;
        break;

    case WEATHER_RAINY:
        // 縦2 × 横2：20度くらいの右下 / 左下
        bandRows = 2;
        bandCols = 2;
        baseSpeed = 45.0f;
        break;

    case WEATHER_SNOWY:
        // 縦4 × 横2：45度くらいの↘ / ↙
        bandRows = 4;
        bandCols = 2;
        baseSpeed = 25.0f;
        break;

    case WEATHER_THUNDERSTORM:
        // 縦8 × 横8：45度で ↗ ↖ ↘ ↙
        bandRows = 8;
        bandCols = 8;
        baseSpeed = 55.0f;
        break;

    default:
        break;
    }

    // バンドごとのベクトル
    vector<vector<ofVec2f>> bandVel(
        bandRows, vector<ofVec2f>(bandCols, ofVec2f(0, 0))
    );

    float degToRad = PI / 180.0f;

    // === バンドごとの方向をランダム決定 ===
    for (int br = 0; br < bandRows; ++br) {
        for (int bc = 0; bc < bandCols; ++bc) {

            ofVec2f v(0, 0);

            if (currentWeather == WEATHER_CLOUDY) {
                float sx = randomSign();
                v.set(sx * baseSpeed, 0.0f);
            }
            else if (currentWeather == WEATHER_RAINY) {
                float sx = randomSign();   // 左 or 右
                float angle = 20.0f * degToRad;
                float vy = baseSpeed * cos(angle);  // 下方向
                float vx = baseSpeed * sin(angle) * sx;
                v.set(vx, vy);
            }
            else if (currentWeather == WEATHER_SNOWY) {
                float sx = randomSign();   // 右 or 左
                float vy = baseSpeed * (1.0f / sqrtf(2.0f));
                float vx = baseSpeed * (1.0f / sqrtf(2.0f)) * sx;
                v.set(vx, vy);
            }
            else if (currentWeather == WEATHER_THUNDERSTORM) {
                int dir = ofRandom(4); // 0〜3
                float sx = (dir == 0 || dir == 2) ? 1.0f : -1.0f;
                float sy = (dir == 0 || dir == 1) ? -1.0f : 1.0f;
                float vx = baseSpeed * (1.0f / sqrtf(2.0f)) * sx;
                float vy = baseSpeed * (1.0f / sqrtf(2.0f)) * sy;
                v.set(vx, vy);
            }

            bandVel[br][bc] = v;
        }
    }

    // === バンドごとのベクトルを CA グリッド全体に展開 ===
    for (int y = 0; y < caRows; ++y) {
        for (int x = 0; x < caCols; ++x) {
            int br = (bandRows > 0) ? ofClamp(y * bandRows / caRows, 0, bandRows - 1) : 0;
            int bc = (bandCols > 0) ? ofClamp(x * bandCols / caCols, 0, bandCols - 1) : 0;
            flowField[y][x] = bandVel[br][bc];
        }
    }
}

//--------------------------------------------------------------
void ofApp::stepChaos() {
    chaosX = chaosR * chaosX * (1.0 - chaosX);
    if (chaosX < 0.0) chaosX = 0.0;
    if (chaosX > 1.0) chaosX = 1.0;
}

//--------------------------------------------------------------
void ofApp::updateWeatherByChaos() {
    if (weatherTimer <= 0.0f) return;

    stepChaos();

    float interval = ofMap(
        chaosX,
        0.0, 1.0,
        weatherBaseMin, weatherBaseMax,
        true
    );

    if (weatherTimer < interval) {
        return;
    }

    weatherTimer = 0.0f;

    int  step = 0;
    bool forceThunder = false;

    if (chaosX < 0.60) {
        step = +1;
    }
    else if (chaosX < 0.80) {
        step = -1;
    }
    else if (chaosX < 0.95) {
        step = +2;
    }
    else {
        forceThunder = true;
    }

    applyWeatherStep(step, forceThunder);
}

//--------------------------------------------------------------
void ofApp::applyWeatherStep(int step, bool forceThunder) {
    if (forceThunder) {
        currentWeather = WEATHER_THUNDERSTORM;
        generateFlowFieldForCurrentWeather();
        return;
    }

    int idx = 0;
    switch (currentWeather) {
    case WEATHER_SUNNY:        idx = 0; break;
    case WEATHER_CLOUDY:       idx = 1; break;
    case WEATHER_RAINY:        idx = 2; break;
    case WEATHER_SNOWY:        idx = 3; break;
    case WEATHER_THUNDERSTORM: idx = 2; break;
    }

    const int cycleSize = 4;

    int newIdx = idx + step;
    while (newIdx < 0)          newIdx += cycleSize;
    while (newIdx >= cycleSize) newIdx -= cycleSize;

    WeatherType nextWeather;
    switch (newIdx) {
    case 0: nextWeather = WEATHER_SUNNY;  break;
    case 1: nextWeather = WEATHER_CLOUDY; break;
    case 2: nextWeather = WEATHER_RAINY;  break;
    case 3: nextWeather = WEATHER_SNOWY;  break;
    default: nextWeather = WEATHER_SUNNY; break;
    }

    currentWeather = nextWeather;
    generateFlowFieldForCurrentWeather();
}

//--------------------------------------------------------------
void ofApp::randomizeCA() {
    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {
            ca[y][x] = ofRandom(1.0f) < 0.5f ? 0 : 1;
        }
    }
}

//--------------------------------------------------------------
void ofApp::update() {
    float dt = ofGetLastFrameTime();

    // === 天候ごとの CA 更新スピード ===
    switch (currentWeather) {
    case WEATHER_SUNNY:
        caUpdateInterval = 0.25f;
        cloudUpdateInterval = 0.35f;
        break;

    case WEATHER_CLOUDY:
        caUpdateInterval = 0.20f;
        cloudUpdateInterval = 0.30f;
        break;

    case WEATHER_RAINY:
        caUpdateInterval = 0.14f;
        cloudUpdateInterval = 0.24f;
        break;

    case WEATHER_SNOWY:
        caUpdateInterval = 0.18f;
        cloudUpdateInterval = 0.28f;
        break;

    case WEATHER_THUNDERSTORM:
        caUpdateInterval = 0.10f;
        cloudUpdateInterval = 0.20f;
        break;
    }

    flowTime += dt;

    caTimer += dt;
    if (caTimer >= caUpdateInterval) {
        updateCA();
        caTimer = 0.0f;
    }

    cloudTimer += dt;
    if (cloudTimer >= cloudUpdateInterval) {
        updateCloudCA();
        cloudTimer = 0.0f;
    }

    weatherTimer += dt;
    updateWeatherByChaos();
}

//--------------------------------------------------------------
// CA 更新：B3/S23 → ベクトル場に沿って移動（勝者ルール）→ カオス再生成
void ofApp::updateCA() {
    if (caCols <= 0 || caRows <= 0) return;

    // ---------- 1. ライフゲームの生死判定（ベース） ----------
    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {

            int aliveNeighbors = 0;

            for (int j = -1; j <= 1; j++) {
                for (int i = -1; i <= 1; i++) {
                    if (i == 0 && j == 0) continue;

                    int nx = (x + i + caCols) % caCols;
                    int ny = (y + j + caRows) % caRows;

                    aliveNeighbors += ca[ny][nx];
                }
            }

            int current = ca[y][x];
            int nextState = 0;

            if (current == 1) {
                if (aliveNeighbors == 2 || aliveNeighbors == 3) {
                    nextState = 1;
                } else {
                    nextState = 0;
                    // 死んだセルから雲を発生させる
                    cloudCA[y][x] = 1;
                }
            } else {
                if (aliveNeighbors == 3) {
                    nextState = 1;
                } else {
                    nextState = 0;
                }
            }

            caNext[y][x] = nextState;
        }
    }

    // ---------- 2. ベクトル場に沿った移動 ＋ 勝者ルール ----------
    vector<vector<int>> movedGrid(caRows, vector<int>(caCols, 0));
    vector<vector<int>> candidateCount(caRows, vector<int>(caCols, 0));

    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {

            if (caNext[y][x] != 1) {
                continue;
            }

            int dx = 0, dy = 0;
            getFlowDirForCell(x, y, dx, dy);

            int tx = (x + dx + caCols) % caCols;
            int ty = (y + dy + caRows) % caRows;

            int& cnt = candidateCount[ty][tx];
            cnt++;

            float r = ofRandom(1.0f);
            if (r < 1.0f / (float)cnt) {
                movedGrid[ty][tx] = 1;
            }
        }
    }

    // ---------- 3. カオス＋スカスカ領域への再生成 ----------
    int aliveCount = 0;
    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {
            if (movedGrid[y][x] == 1) {
                aliveCount++;
            }
        }
    }

    int totalCells = caCols * caRows;
    int minAliveCells = static_cast<int>(totalCells * 0.03f); // 3%

    if (aliveCount < minAliveCells) {
        int maxSeeds = 6;
        int seedCount = ofMap(chaosX, 0.0f, 1.0f, 1, maxSeeds, true);

        for (int s = 0; s < seedCount; s++) {
            for (int tries = 0; tries < 50; tries++) {
                int rx = ofRandom(caCols);
                int ry = ofRandom(caRows);

                if (movedGrid[ry][rx] == 1) continue;

                int neighbors = 0;
                for (int j = -1; j <= 1; j++) {
                    for (int i = -1; i <= 1; i++) {
                        if (i == 0 && j == 0) continue;
                        int nx = (rx + i + caCols) % caCols;
                        int ny = (ry + j + caRows) % caRows;
                        neighbors += movedGrid[ny][nx];
                    }
                }

                if (neighbors <= 1) {
                    movedGrid[ry][rx] = 1;
                    break;
                }
            }
        }
    }

    ca = movedGrid;
}

//--------------------------------------------------------------
// 雲 CA 更新（シンプルな B3/S2 くらいのルールでふわっと減衰させる）
void ofApp::updateCloudCA() {
    if (caCols <= 0 || caRows <= 0) return;

    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {

            int aliveNeighbors = 0;

            for (int j = -1; j <= 1; j++) {
                for (int i = -1; i <= 1; i++) {
                    if (i == 0 && j == 0) continue;

                    int nx = (x + i + caCols) % caCols;
                    int ny = (y + j + caRows) % caRows;

                    aliveNeighbors += cloudCA[ny][nx];
                }
            }

            int current = cloudCA[y][x];
            int nextState = 0;

            if (current == 1) {
                if (aliveNeighbors == 2) {
                    nextState = 1;
                } else {
                    nextState = 0;
                }
            } else {
                if (aliveNeighbors == 3) {
                    nextState = 1;
                } else {
                    nextState = 0;
                }
            }

            cloudNext[y][x] = nextState;
        }
    }

    cloudCA = cloudNext;
}

//--------------------------------------------------------------
void ofApp::getFlowDirForCell(int gx, int gy, int& dx, int& dy) {
    dx = 0;
    dy = 0;

    if (caCols <= 0 || caRows <= 0) return;

    switch (currentWeather) {
    case WEATHER_SUNNY:
        dx = 0;
        dy = 0;
        break;

    case WEATHER_C