## tarans for


#include "ofApp.h"
#include <cmath>

//--------------------------------------------------------------
void ofApp::setup() {
    ofSetBackgroundColor(0);
    currentWeather = WEATHER_SUNNY;

    // === セルオートマトン初期化 ===
    cellSize = 20;
    caCols = ofGetWidth() / cellSize;
    caRows = ofGetHeight() / cellSize;

    ca.assign(caRows, vector<int>(caCols, 0));
    caNext.assign(caRows, vector<int>(caCols, 0));
    randomizeCA();

    caUpdateInterval = 0.2f;
    caTimer = 0.0f;

    // === 雲用 CA 初期化 ===
    cloudCA.assign(caRows, vector<int>(caCols, 0));
    cloudNext.assign(caRows, vector<int>(caCols, 0));
    cloudUpdateInterval = 0.30f;
    cloudTimer = 0.0f;

    // === ベクトル場初期化 ===
    flowField.assign(caRows, vector<ofVec2f>(caCols, ofVec2f(0, 0)));
    flowTime = 0.0f;
    generateFlowFieldForCurrentWeather();

    // === 天気カオス制御の初期化 ===
    chaosR = 3.9;                       // カオス度合い
    chaosX = ofRandom(0.1, 0.9);        // 初期値 (0,1) の間でランダム
    weatherTimer = 0.0f;
    weatherBaseMin = 5.0f;              // 最短 5 秒ごとに天気が変わる
    weatherBaseMax = 25.0f;             // 最長 25 秒くらい変わらない
}

//--------------------------------------------------------------
//--------------------------------------------------------------
// 現在の天気に応じてベクトル場を生成（バンドごとに方向をランダム）
void ofApp::generateFlowFieldForCurrentWeather() {
    flowTime = 0.0f;  // 天気が変わるたびに時間もリセット

    flowField.assign(caRows, vector<ofVec2f>(caCols, ofVec2f(0, 0)));

    // 晴れはベクトル場なし（全部0のまま）
    if (currentWeather == WEATHER_SUNNY) {
        return;
    }

    // バンドの分割数
    int bandRows = 1;
    int bandCols = 1;
    float baseSpeed = 20.0f;  // px/sec くらいの基準速度

    // 小さなヘルパー：±1 を返す
    auto randomSign = []() -> float {
        return (ofRandomuf() < 0.5f) ? -1.0f : 1.0f;
        };

    switch (currentWeather) {
    case WEATHER_CLOUDY:
        // 縦1 × 横4：左右に流れる層
        bandRows = 1;
        bandCols = 4;
        baseSpeed = 25.0f;
        break;

    case WEATHER_RAINY:
        // 縦2 × 横2：20度くらいの右下 / 左下
        bandRows = 2;
        bandCols = 2;
        baseSpeed = 45.0f;
        break;

    case WEATHER_SNOWY:
        // 縦4 × 横2：45度くらいの↘ / ↙
        bandRows = 4;
        bandCols = 2;
        baseSpeed = 25.0f;
        break;

    case WEATHER_THUNDERSTORM:
        // 縦8 × 横8：45度で ↗ ↖ ↘ ↙
        bandRows = 8;
        bandCols = 8;
        baseSpeed = 55.0f;
        break;

    default:
        break;
    }

    // バンドごとのベクトル
    vector<vector<ofVec2f>> bandVel(
        bandRows, vector<ofVec2f>(bandCols, ofVec2f(0, 0))
    );

    // 角度関連（ラジアン）
    float degToRad = PI / 180.0f;

    // === バンドごとの方向をランダム決定 ===
    for (int br = 0; br < bandRows; ++br) {
        for (int bc = 0; bc < bandCols; ++bc) {

            ofVec2f v(0, 0);

            if (currentWeather == WEATHER_CLOUDY) {
                // 横4分割：→ or ←
                float sx = randomSign();
                v.set(sx * baseSpeed, 0.0f);
            }
            else if (currentWeather == WEATHER_RAINY) {
                // 20度くらいの右下 / 左下
                float sx = randomSign();   // 左 or 右
                float angle = 20.0f * degToRad;
                float vy = baseSpeed * cos(angle);  // 下方向
                float vx = baseSpeed * sin(angle) * sx;

                v.set(vx, vy); // y+ が下
            }
            else if (currentWeather == WEATHER_SNOWY) {
                // 45度の↘ / ↙
                float sx = randomSign();   // 右 or 左
                float vy = baseSpeed * (1.0f / sqrtf(2.0f));
                float vx = baseSpeed * (1.0f / sqrtf(2.0f)) * sx;

                v.set(vx, vy);
            }
            else if (currentWeather == WEATHER_THUNDERSTORM) {
                // 45度で ↗ ↖ ↘ ↙ のどれか
                int dir = ofRandom(4); // 0〜3
                float sx = (dir == 0 || dir == 2) ? 1.0f : -1.0f;
                float sy = (dir == 0 || dir == 1) ? -1.0f : 1.0f; // 上 or 下

                float vx = baseSpeed * (1.0f / sqrtf(2.0f)) * sx;
                float vy = baseSpeed * (1.0f / sqrtf(2.0f)) * sy;

                v.set(vx, vy);
            }

            bandVel[br][bc] = v;
        }
    }

    // === バンドごとのベクトルを CA グリッド全体に展開 ===
    for (int y = 0; y < caRows; ++y) {
        for (int x = 0; x < caCols; ++x) {
            int br = (bandRows > 0) ? ofClamp(y * bandRows / caRows, 0, bandRows - 1) : 0;
            int bc = (bandCols > 0) ? ofClamp(x * bandCols / caCols, 0, bandCols - 1) : 0;
            flowField[y][x] = bandVel[br][bc];
        }
    }
}

//--------------------------------------------------------------
void ofApp::stepChaos() {
    // ロジスティック写像: x_{n+1} = r * x_n * (1 - x_n)
    chaosX = chaosR * chaosX * (1.0 - chaosX);

    // 念のため 0〜1 にクランプ
    if (chaosX < 0.0) chaosX = 0.0;
    if (chaosX > 1.0) chaosX = 1.0;
}

//--------------------------------------------------------------
void ofApp::updateWeatherByChaos() {
    // まだ基準時間に達していなければ何もしない
    if (weatherTimer <= 0.0f) return;

    // カオスを1ステップ進めて、今の chaosX から「次に変わるまでの間隔」を計算
    stepChaos();

    float interval = ofMap(
        chaosX,
        0.0, 1.0,
        weatherBaseMin, weatherBaseMax,
        true
    );
    // chaosX が大きいほど interval は短く（＝天気が変わりやすい）

    if (weatherTimer < interval) {
        // まだ変わるタイミングではない
        return;
    }

    // ここに来たら「そろそろ天気を変える」
    weatherTimer = 0.0f;

    // chaosX から遷移の方向・雷の有無を決める
    int  step = 0;
    bool forceThunder = false;

    if (chaosX < 0.60) {
        step = +1;                // 通常のサイクル：次へ
    }
    else if (chaosX < 0.80) {
        step = -1;                // 1つ戻る（揺り戻し）
    }
    else if (chaosX < 0.95) {
        step = +2;                // 1つスキップ（急変）
    }
    else {
        // 稀なイベント：雷雨に飛ぶ
        forceThunder = true;
    }

    applyWeatherStep(step, forceThunder);
}

//--------------------------------------------------------------
void ofApp::applyWeatherStep(int step, bool forceThunder) {
    // 雷雨を強制したい場合（chaosX が 0.95 以上など）
    if (forceThunder) {
        currentWeather = WEATHER_THUNDERSTORM;
        generateFlowFieldForCurrentWeather(); // ★ ベクトル場更新
        return;
    }

    // 天候を 0〜3 のインデックスにマップ（雷雨は "雨寄り" として扱う）
    int idx = 0;
    switch (currentWeather) {
    case WEATHER_SUNNY:        idx = 0; break;
    case WEATHER_CLOUDY:       idx = 1; break;
    case WEATHER_RAINY:        idx = 2; break;
    case WEATHER_SNOWY:        idx = 3; break;
    case WEATHER_THUNDERSTORM: idx = 2; break; // 雷雨は雨ポジション
    }

    // サイクルは [SUNNY, CLOUDY, RAINY, SNOWY] の4つループ
    const int cycleSize = 4;

    // 進む/戻る/スキップを反映（負の値にも対応）
    int newIdx = idx + step;
    while (newIdx < 0)          newIdx += cycleSize;
    while (newIdx >= cycleSize) newIdx -= cycleSize;

    // インデックスから天候へ戻す
    WeatherType nextWeather;
    switch (newIdx) {
    case 0: nextWeather = WEATHER_SUNNY;  break;
    case 1: nextWeather = WEATHER_CLOUDY; break;
    case 2: nextWeather = WEATHER_RAINY;  break;
    case 3: nextWeather = WEATHER_SNOWY;  break;
    default: nextWeather = WEATHER_SUNNY; break;
    }

    currentWeather = nextWeather;
    generateFlowFieldForCurrentWeather(); // ★ 天気変更時にベクトル場再生成
}

//--------------------------------------------------------------
void ofApp::randomizeCA() {
    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {
            ca[y][x] = ofRandom(1.0f) < 0.5f ? 0 : 1;
        }
    }
}






void ofApp::update() {
    float dt = ofGetLastFrameTime();

    // === 天候ごとの CA 更新スピード ===
    switch (currentWeather) {
    case WEATHER_SUNNY:
        caUpdateInterval = 0.25f;  // 一番ゆっくり
        cloudUpdateInterval = 0.35f;
        break;

    case WEATHER_CLOUDY:
        caUpdateInterval = 0.20f;  // 晴れより少し速い
        cloudUpdateInterval = 0.30f;
        break;

    case WEATHER_RAINY:
        caUpdateInterval = 0.14f;  // さらに速い
        cloudUpdateInterval = 0.24f;
        break;

    case WEATHER_SNOWY:
        caUpdateInterval = 0.18f;  // 曇りと雨の中間
        cloudUpdateInterval = 0.28f;
        break;

    case WEATHER_THUNDERSTORM:
        caUpdateInterval = 0.10f;  // 一番速い
        cloudUpdateInterval = 0.20f;
        break;
    }

    // ベクトル場の時間（風の進み）はそのまま
    flowTime += dt;

    // === 天気 CA の時間管理 ===
    caTimer += dt;
    if (caTimer >= caUpdateInterval) {
        updateCA();
        caTimer = 0.0f;
    }

    // === 雲 CA の時間管理 ===
    cloudTimer += dt;
    if (cloudTimer >= cloudUpdateInterval) {
        updateCloudCA();
        cloudTimer = 0.0f;
    }

    // === カオスで天気を揺らがせる ===
    weatherTimer += dt;
    updateWeatherByChaos();
}


//--------------------------------------------------------------
// 天気 CA 更新（トーラス境界、死んだセルから雲 CA を生む）
//
// 「増える力」を各天候ごとの誕生確率として導入する。
//  - ベースルールは B3 / S23（標準ライフゲーム）
//  - ただし B3（誕生）になるときだけ、天気ごとのパーセンテージで確率判定する。
//    晴れ: 60%, 曇り: 40%, 雨: 20%, 雪: 50%, 雷: 60%





void ofApp::updateCA() {

    // 停止回避用のランダム誕生確率（必要なら 0.0f にしてOFFにもできる）
    const float randomBirthProb = 0.005f; // 0.5% くらい

    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {

            int current = ca[y][x];

            // 8近傍の生存セル数（トーラス境界）
            int aliveNeighbors = 0;
            for (int j = -1; j <= 1; j++) {
                for (int i = -1; i <= 1; i++) {
                    if (i == 0 && j == 0) continue; // 自分自身は含めない

                    int nx = (x + i + caCols) % caCols;
                    int ny = (y + j + caRows) % caRows;

                    aliveNeighbors += ca[ny][nx];
                }
            }

            int nextState = current;

            // --- 基本ルール：B3 / S23 (Game of Life) ---
            if (current == 1) {
                // 生きているセル：近傍 2 or 3 で生存
                if (aliveNeighbors == 2 || aliveNeighbors == 3) {
                    nextState = 1;
                }
                else {
                    nextState = 0;
                }
            }
            else {
                // 死んでいるセル：近傍 3 で誕生
                if (aliveNeighbors == 3) {
                    nextState = 1;
                }
                else {
                    nextState = 0;
                }

                // ★ 停止回避用のノイズ：
                //    近傍が少ない場所で、ごくたまにランダム誕生させる。
                if (nextState == 0 && aliveNeighbors == 0) {
                    float r = ofRandom(1.0f);
                    if (r < randomBirthProb) {
                        nextState = 1;
                    }
                }
            }

            // 「今まで生きていたのに次フレームで死ぬセル」から雲 CA を誕生させる
            if (current == 1 && nextState == 0) {
                cloudCA[y][x] = 1;
            }

            caNext[y][x] = nextState;
        }
    }

    ca = caNext;
}





//--------------------------------------------------------------
// 雲 CA 更新（B3 / S2 + 近傍3は確率生存）＋トーラス境界
void ofApp::updateCA() {
    if (caCols <= 0 || caRows <= 0) return;

    // ---------- 1. ライフゲームの生死判定（ベース） ----------
    // ca を元に B3/S23 ルールで「生きる/死ぬ」を caNext に書き込む
    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {

            int aliveNeighbors = 0;

            // 8近傍（トーラス境界）
            for (int j = -1; j <= 1; j++) {
                for (int i = -1; i <= 1; i++) {
                    if (i == 0 && j == 0) continue; // 自分自身

                    int nx = (x + i + caCols) % caCols;
                    int ny = (y + j + caRows) % caRows;

                    aliveNeighbors += ca[ny][nx];
                }
            }

            int current = ca[y][x];
            int nextState = 0;

            if (current == 1) {
                // 生きているセル：近傍が 2 or 3 なら生存
                if (aliveNeighbors == 2 || aliveNeighbors == 3) {
                    nextState = 1;
                }
                else {
                    nextState = 0;
                }
            }
            else {
                // 死んでいるセル：近傍が 3 なら誕生
                if (aliveNeighbors == 3) {
                    nextState = 1;
                }
                else {
                    nextState = 0;
                }
            }

            caNext[y][x] = nextState;
        }
    }

    // ---------- 2. ベクトル場に沿った移動 ＋ 勝者ルール ----------
    // movedGrid: 移動後の CA 状態
    // candidateCount: 各マスに「何セル来ようとしたか」のカウント
    vector<vector<int>> movedGrid(caRows, vector<int>(caCols, 0));
    vector<vector<int>> candidateCount(caRows, vector<int>(caCols, 0));

    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {

            if (caNext[y][x] != 1) {
                continue; // 死んでいる予定のセルは移動しない
            }

            // このセルが生き残るので、ベクトル場に沿って移動先を決める
            int dx = 0, dy = 0;
            getFlowDirForCell(x, y, dx, dy);

            int tx = (x + dx + caCols) % caCols;
            int ty = (y + dy + caRows) % caRows;

            // 勝者ルール：このマスに来ようとした回数を増やす
            int& cnt = candidateCount[ty][tx];
            cnt++;

            // Reservoir sampling 的に「たまに勝者を入れ替える」ランダム勝者
            float r = ofRandom(1.0f);
            if (r < 1.0f / (float)cnt) {
                // 今の候補を勝者にする
                movedGrid[ty][tx] = 1;
            }
            // それ以外の場合は、すでに入っているもの（もしあれば）を勝者として残す
        }
    }

    // ---------- 3. カオス＋スカスカ領域への再生成 ----------

    // まず今の生存セル数を数える
    int aliveCount = 0;
    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {
            if (movedGrid[y][x] == 1) {
                aliveCount++;
            }
        }
    }

    // 「少ない」とみなす閾値（全体の 2〜3% くらい）
    int totalCells = caCols * caRows;
    int minAliveCells = static_cast<int>(totalCells * 0.03f); // 3% 以下なら「ほぼ消えかけ」

    if (aliveCount < minAliveCells) {
        // chaosX を使って「どれくらい新しい塊を落とすか」を決める
        // chaosX は 0〜1 の値なので、
        int maxSeeds = 6; // 最大 6 か所くらい
        int seedCount = ofMap(chaosX, 0.0f, 1.0f, 1, maxSeeds, true);

        for (int s = 0; s < seedCount; s++) {
            // スカスカな場所（近傍の生存セルが少ないところ）を探す
            bool placed = false;
            for (int tries = 0; tries < 50; tries++) {
                int rx = ofRandom(caCols);
                int ry = ofRandom(caRows);

                if (movedGrid[ry][rx] == 1) continue; // すでに生きているところは避ける

                // 近傍の生存数を数える（ここでは8近傍）
                int neighbors = 0;
                for (int j = -1; j <= 1; j++) {
                    for (int i = -1; i <= 1; i++) {
                        if (i == 0 && j == 0) continue;
                        int nx = (rx + i + caCols) % caCols;
                        int ny = (ry + j + caRows) % caRows;
                        neighbors += movedGrid[ny][nx];
                    }
                }

                // ほとんど誰もいない場所（0〜1）だけに生成
                if (neighbors <= 1) {
                    movedGrid[ry][rx] = 1;
                    placed = true;
                    break;
                }
            }
            (void)placed; // 使わないけど、将来デバッグに使える
        }
    }

    // ---------- 4. 次ステップの CA として確定 ----------
    ca = movedGrid;
}





void ofApp::getFlowDirForCell(int gx, int gy, int& dx, int& dy) {
    dx = 0;
    dy = 0;

    // 安全策：列・行数チェック
    if (caCols <= 0 || caRows <= 0) return;

    switch (currentWeather) {
    case WEATHER_SUNNY:
        // 晴れ：流れなし（その場にとどまる）
        dx = 0;
        dy = 0;
        break;

    case WEATHER_CLOUDY:
    {
        // 曇り：縦方向に4分割して、左右に流す
        int bandX = (gx * 4) / caCols; // 0〜3
        if (bandX % 2 == 0) {
            dx = 1;   // 右へ
        }
        else {
            dx = -1;  // 左へ
        }
        dy = 0;
        break;
    }

    case WEATHER_RAINY:
    {
        // 雨：縦2×横2のざっくり分割で斜め下方向
        int bandX = (gx * 2) / caCols; // 0 or 1
        int bandY = (gy * 2) / caRows; // 0 or 1

        dy = 1; // 下方向は固定

        if (bandX == 0) {
            dx = -1; // 左下
        }
        else {
            dx = 1;  // 右下
        }

        // 上半分と下半分で、少しだけ左右を変えるなども可能
        // （今はシンプルにこのまま）
        (void)bandY;
        break;
    }

    case WEATHER_SNOWY:
    {
        // 雪：縦4分割で右下/左下を交互、ゆっくり落ちるイメージ
        int bandX = (gx * 4) / caCols; // 0〜3

        dy = 1; // 下へ

        if (bandX % 2 == 0) {
            dx = 1;  // 右下
        }
        else {
            dx = -1; // 左下
        }
        break;
    }

    case WEATHER_THUNDERSTORM:
    {
        // 雷：縦8×横8の細かいグリッドで、4方向の斜めベクトル
        int bx = (gx * 8) / caCols; // 0〜7
        int by = (gy * 8) / caRows; // 0〜7

        // x 偶数/奇数で左右、y 偶数/奇数で上下を決定
        dx = (bx % 2 == 0) ? -1 : 1;
        dy = (by % 2 == 0) ? -1 : 1;
        break;
    }

    default:
        dx = 0;
        dy = 0;
        break;
    }
}

//--------------------------------------------------------------
// 天気アイコンを描画（flowField に従って流す）
void ofApp::drawCA() {
    int w = ofGetWidth();
    int h = ofGetHeight();

    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {
            if (ca[y][x] == 0) continue; // 死んでいるセルはスキップ

            float baseX = x * cellSize + cellSize * 0.5f;
            float baseY = y * cellSize + cellSize * 0.5f;

            ofVec2f v = flowField[y][x];
            float cx = baseX + v.x * flowTime;
            float cy = baseY + v.y * flowTime;

            // 画面端でラップ（トーラス）
            if (w > 0) {
                cx = fmodf(cx, (float)w);
                if (cx < 0) cx += w;
            }
            if (h > 0) {
                cy = fmodf(cy, (float)h);
                if (cy < 0) cy += h;
            }

            float baseR = cellSize * 0.45f;

            // 天候ごとのベース色
            ofColor baseColor;
            switch (currentWeather) {
            case WEATHER_SUNNY:
                baseColor = ofColor(255, 240, 150);   // 明るい黄色
                break;
            case WEATHER_CLOUDY:
                baseColor = ofColor(190, 190, 210);   // グレー
                break;
            case WEATHER_RAINY:
                baseColor = ofColor(100, 140, 255);   // 青
                break;
            case WEATHER_SNOWY:
                baseColor = ofColor(230, 250, 255);   // ほぼ白
                break;
            case WEATHER_THUNDERSTORM:
                baseColor = ofColor(255, 230, 80);    // 強い黄色
                break;
            default:
                baseColor = ofColor(255, 255, 255);
                break;
            }

            ofSetColor(baseColor);

            switch (currentWeather) {
                // 晴れ：円
            case WEATHER_SUNNY:
                ofDrawCircle(cx, cy, baseR);
                break;

                // くもり：平行四辺形
            case WEATHER_CLOUDY:
            {
                float w0 = baseR * 3.0f;
                float h0 = baseR * 1.6f;
                float skew = w0 * 0.3f;

                ofDrawLine(cx - w0 / 2 + skew, cy - h0 / 2,
                    cx + w0 / 2 + skew, cy - h0 / 2);
                ofDrawLine(cx + w0 / 2 + skew, cy - h0 / 2,
                    cx + w0 / 2 - skew, cy + h0 / 2);
                ofDrawLine(cx + w0 / 2 - skew, cy + h0 / 2,
                    cx - w0 / 2 - skew, cy + h0 / 2);
                ofDrawLine(cx - w0 / 2 - skew, cy + h0 / 2,
                    cx - w0 / 2 + skew, cy - h0 / 2);
            }
            break;

            // 雨：ひし形
            case WEATHER_RAINY:
            {
                float r = baseR * 1.2f;
                ofDrawLine(cx, cy - r,
                    cx + r, cy);
                ofDrawLine(cx + r, cy,
                    cx, cy + r);
                ofDrawLine(cx, cy + r,
                    cx - r, cy);
                ofDrawLine(cx - r, cy,
                    cx, cy - r);
            }
            break;

            // 雪：六角形
            case WEATHER_SNOWY:
            {
                float r = baseR * 1.1f;
                ofPolyline poly;
                for (int i = 0; i < 6; i++) {
                    float angle = TWO_PI * i / 6.0f;
                    float vx = cx + cos(angle) * r;
                    float vy = cy + sin(angle) * r;
                    poly.addVertex(vx, vy);
                }
                poly.close();
                poly.draw();
            }
            break;

            // 雷雨：正三角形
            case WEATHER_THUNDERSTORM:
            {
                float r = baseR * 1.3f;
                ofDrawTriangle(
                    cx, cy - r,
                    cx - r, cy + r,
                    cx + r, cy + r
                );
            }
            break;

            default:
                break;
            }
        }
    }
}






//--------------------------------------------------------------
// 雲 CA を描画（量子表示＋flowField に従って流す）
void ofApp::drawCloudCA() {
    int w = ofGetWidth();
    int h = ofGetHeight();

    for (int y = 0; y < caRows; y++) {
        for (int x = 0; x < caCols; x++) {
            if (cloudCA[y][x] == 0) continue;

            float baseX = x * cellSize + cellSize * 0.5f;
            float baseY = y * cellSize + cellSize * 0.5f;

            ofVec2f v = flowField[y][x];
            float cx = baseX + v.x * flowTime;
            float cy = baseY + v.y * flowTime;

            if (w > 0) {
                cx = fmodf(cx, (float)w);
                if (cx < 0) cx += w;
            }
            if (h > 0) {
                cy = fmodf(cy, (float)h);
                if (cy < 0) cy += h;
            }

            float baseR = cellSize * 0.45f;

            // 雲のベース色は天気によって少し変える
            ofColor baseColor;
            switch (currentWeather) {
            case WEATHER_SUNNY:
                baseColor = ofColor(255, 240, 200);
                break;
            case WEATHER_CLOUDY:
                baseColor = ofColor(210, 210, 230);
                break;
            case WEATHER_RAINY:
                baseColor = ofColor(170, 200, 255);
                break;
            case WEATHER_SNOWY:
                baseColor = ofColor(240, 255, 255);
                break;
            case WEATHER_THUNDERSTORM:
                baseColor = ofColor(255, 240, 160);
                break;
            default:
                baseColor = ofColor(255, 255, 255);
                break;
            }

            float seed = x * 17.0f + y * 31.0f + 1000.0f;

            drawCloudBlob(cx, cy, baseR * 1.3f, baseColor, seed);
        }
    }
}







//--------------------------------------------------------------
// 雲ブロブ：量子表示（ピクセル敷き詰め＋点滅）、天気ごとの性格付き
void ofApp::drawCloudBlob(float cx, float cy,
    float baseR,
    const ofColor& baseColor,
    float seed)
{
    // 雲全体の横幅・高さ（baseR から決める）
    float W = baseR * 4.0f;
    float H = baseR * 2.4f;

    struct Bubble {
        float nx, ny; // 雲中心からの相対位置（-0.5〜0.5くらいの正規化座標）
        float r;      // baseR に対する半径倍率
    };

    // 枠の形（輪郭）は固定
    static const Bubble bubbles[] = {
        { -0.45f,  0.05f, 0.95f }, // 左端
        { -0.25f,  0.30f, 1.05f }, // 左上
        {  0.00f,  0.35f, 1.15f }, // 真上
        {  0.25f,  0.30f, 1.05f }, // 右上
        {  0.45f,  0.05f, 0.95f }, // 右端
        { -0.25f, -0.25f, 0.80f }, // 左下
        {  0.00f, -0.30f, 0.85f }, // 真下
        {  0.25f, -0.25f, 0.80f }  // 右下
    };
    const int bubbleCount = sizeof(bubbles) / sizeof(Bubble);

    auto insideCloud = [&](float px, float py) -> bool {
        for (int i = 0; i < bubbleCount; i++) {
            float bx = cx + bubbles[i].nx * W;
            float by = cy + bubbles[i].ny * H;
            float br = baseR * bubbles[i].r;

            float dx = px - bx;
            float dy = py - by;
            if (dx * dx + dy * dy <= br * br) {
                return true;
            }
        }
        return false;
        };

    // === 量子表示パラメータ（天気ごとに変える） ===
    float flickerSpeed = 2.0f;
    float flickerThreshold = 0.35f;
    float flickerMinStrength = 0.4f;
    float flickerMaxStrength = 1.2f;
    float baseAlpha = 120.0f;
    float whiteLerp = 0.4f;  // 白寄せの度合い

    switch (currentWeather) {
    case WEATHER_SUNNY:
        flickerSpeed = 1.0f;
        flickerThreshold = 0.55f;
        flickerMinStrength = 0.4f;
        flickerMaxStrength = 0.9f;
        baseAlpha = 90.0f;
        whiteLerp = 0.35f;
        break;

    case WEATHER_CLOUDY:
        flickerSpeed = 1.2f;
        flickerThreshold = 0.45f;
        flickerMinStrength = 0.5f;
        flickerMaxStrength = 1.0f;
        baseAlpha = 110.0f;
        whiteLerp = 0.45f;
        break;

    case WEATHER_RAINY:
        flickerSpeed = 2.0f;
        flickerThreshold = 0.40f;
        flickerMinStrength = 0.6f;
        flickerMaxStrength = 1.1f;
        baseAlpha = 130.0f;
        whiteLerp = 0.5f;
        break;

    case WEATHER_SNOWY:
        flickerSpeed = 1.4f;
        flickerThreshold = 0.38f;
        flickerMinStrength = 0.6f;
        flickerMaxStrength = 1.0f;
        baseAlpha = 140.0f;
        whiteLerp = 0.6f;
        break;

    case WEATHER_THUNDERSTORM:
        flickerSpeed = 4.0f;
        flickerThreshold = 0.30f;
        flickerMinStrength = 0.5f;
        flickerMaxStrength = 1.3f;
        baseAlpha = 160.0f;
        whiteLerp = 0.5f;
        break;
    }

    // 1マスの大きさ（細かいピクセル）
    float cell = baseR * 0.35f * (2.0f / 3.0f);
    if (cell < 1.0f) cell = 1.0f;

    float stepX = cell;
    float stepY = cell;

    ofColor cloudColor = baseColor;
    cloudColor.lerp(ofColor(255, 255, 255), whiteLerp);

    float maxR = std::max(W * 0.5f, H * 0.5f);

    float tGlobal = ofGetElapsedTimef();

    for (float oy = -H * 0.5f; oy <= H * 0.5f; oy += stepY) {
        for (float ox = -W * 0.5f; ox <= W * 0.5f; ox += stepX) {

            float px = cx + ox;
            float py = cy + oy;

            if (!insideCloud(px, py)) continue;

            // 中心からの距離
            float dx = px - cx;
            float dy = py - cy;
            float dist = sqrtf(dx * dx + dy * dy);
            float t = ofClamp(dist / maxR, 0.0f, 1.0f);

            // 中心が濃く、外側が薄くなるカーブ
            float falloff = 1.0f - powf(t, 1.5f);
            falloff = ofClamp(falloff, 0.0f, 1.0f);

            // 点滅用ノイズ
            float flickerNoise = ofNoise(
                px * 0.12f,
                py * 0.12f,
                seed * 0.3f + tGlobal * flickerSpeed
            );

            // 一定以下なら消灯
            if (flickerNoise < flickerThreshold) {
                continue;
            }

            // オンのときの輝度変動
            float flickerStrength = ofMap(
                flickerNoise,
                flickerThreshold, 1.0f,
                flickerMinStrength, flickerMaxStrength,
                true
            );

            // 静的なムラ
            float staticNoise = ofNoise(px * 0.03f, py * 0.03f, seed * 0.05f);
            float staticFactor = ofLerp(0.9f, 1.1f, staticNoise);

            float alpha = baseAlpha * falloff * flickerStrength * staticFactor;
            alpha = ofClamp(alpha, 0.0f, 255.0f);
            if (alpha < 5.0f) continue;

            ofColor c = cloudColor;
            c.a = static_cast<unsigned char>(alpha);

            ofSetColor(c);
            ofDrawRectangle(px - cell * 0.5f, py - cell * 0.5f, cell, cell);
        }
    }
}





//--------------------------------------------------------------
void ofApp::drawNoisyPolygon(float cx, float cy,
    float baseRadius,
    int sides,
    float rotationRad,
    float noiseScale,
    float noiseAmp,
    float seed,
    float time)
{
    ofPolyline poly;
    poly.clear();

    for (int i = 0; i < sides; i++) {
        float tt = (float)i / (float)sides;
        float angle = rotationRad + TWO_PI * tt;

        float dx = cos(angle);
        float dy = sin(angle);

        float n = ofNoise(
            dx * noiseScale + seed,
            dy * noiseScale + seed * 1.37f,
            time * 0.3f
        );

        float offset = (n - 0.5f) * 2.0f * noiseAmp;
        float r = baseRadius * (1.0f + offset);

        float vx = cx + dx * r;
        float vy = cy + dy * r;
        poly.addVertex(vx, vy);
    }

    poly.close();
    poly.draw();
}




//--------------------------------------------------------------
void ofApp::draw() {
    drawCA();       // 天気アイコン
    drawCloudCA();  // 雲 CA（量子表示）
}



//--------------------------------------------------------------
void ofApp::keyPressed(int key) {
    bool changed = false;

    if (key == '1') {
        currentWeather = WEATHER_SUNNY;
        changed = true;
    }
    if (key == '2') {
        currentWeather = WEATHER_CLOUDY;
        changed = true;
    }
    if (key == '3') {
        currentWeather = WEATHER_RAINY;
        changed = true;
    }
    if (key == '4') {
        currentWeather = WEATHER_SNOWY;
        changed = true;
    }
    if (key == '5') {
        currentWeather = WEATHER_THUNDERSTORM;
        changed = true;
    }

    if (changed) {
        generateFlowFieldForCurrentWeather();  // 手動変更時もベクトル場を更新
    }
}


#pragma once

#include "ofMain.h"
using std::vector;

// 天気の種類
enum WeatherType {
    WEATHER_SUNNY,
    WEATHER_CLOUDY,
    WEATHER_RAINY,
    WEATHER_SNOWY,
    WEATHER_THUNDERSTORM,
};

class ofApp : public ofBaseApp {
public:
    void setup();
    void update();
    void draw();
    void keyPressed(int key);

private:
    // === 現在の天気 ===
    WeatherType currentWeather;

    // === セルオートマトン共通 ===
    int cellSize;
    int caCols;
    int caRows;

    // === 天気用セルオートマトン ===
    vector<vector<int>> ca;
    vector<vector<int>> caNext;
    float caUpdateInterval;
    float caTimer;

    void randomizeCA();
    void updateCA();
    void drawCA();

    // === 雲用セルオートマトン ===
    vector<vector<int>> cloudCA;
    vector<vector<int>> cloudNext;
    float cloudUpdateInterval;
    float cloudTimer;

    void updateCloudCA();
    void drawCloudCA();

    // === ベクトル場（天候による風の向き・速さ） ===
    // CA グリッドと同じサイズで、各セルに速度ベクトルを持つ
    vector<vector<ofVec2f>> flowField;
    // 経過時間（ベクトル場は静的、時間だけ進める）
    float flowTime;

    // 現在の天気に応じて flowField を生成し直す
    void generateFlowFieldForCurrentWeather();

    // === 天気カオス制御 ===
    double chaosX;          // ロジスティック写像の現在値 (0〜1)
    double chaosR;          // カオスのパラメータ (3.8〜4.0あたり)
    float  weatherTimer;    // 天気切り替え用タイマー
    float  weatherBaseMin;  // 天気が変わる最小間隔（秒）
    float  weatherBaseMax;  // 天気が変わる最大間隔（秒）

    void stepChaos();              // chaosX を1ステップ進める
    void updateWeatherByChaos();   // タイミング＋方向を決めて天気を変える
    void applyWeatherStep(int step, bool forceThunder); // 進む/戻る/スキップ/雷

    // === 雲のブロブ描画（量子表示） ===
    void drawCloudBlob(float cx, float cy,
        float baseR,
        const ofColor& baseColor,
        float seed);

    // （おまけ：ノイジーポリゴン、今は使っても使わなくてもOK）
    void drawNoisyPolygon(float cx, float cy,
        float baseRadius,
        int sides,
        float rotationRad,
        float noiseScale,
        float noiseAmp,
        float seed,
        float time);
};



class ofApp : public ofBaseApp {
public:
    // 既存の宣言はそのまま…

    void updateCA();  // これを書き換える

    // ★ 追加：グリッド座標 (gx,gy) に対して、
    //    現在の天気に応じた「整数ベクトル方向 (dx,dy)」を返すヘルパー
    void getFlowDirForCell(int gx, int gy, int& dx, int& dy);
};






