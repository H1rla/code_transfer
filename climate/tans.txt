#pragma once

#include "ofMain.h"
#include <vector>

using std::vector;

// 天気の種類
enum WeatherType {
    WEATHER_SUNNY = 0,
    WEATHER_CLOUDY,
    WEATHER_RAINY,
    WEATHER_SNOWY,
    WEATHER_THUNDERSTORM
};

class ofApp : public ofBaseApp {
public:
    void setup();
    void update();
    void draw();
    void keyPressed(int key);

private:
    // === 現在の天気 ===
    WeatherType currentWeather;

    // === セルオートマトン共通 ===
    int cellSize;
    int caCols;
    int caRows;

    // 天候 CA（主役）
    vector<vector<int>> ca;      // 現在の生死
    vector<vector<int>> caNext;  // 基本ルール用のバッファ

    // HP（勝者レベルとして扱う） 0〜maxHP
    vector<vector<int>> caHP;
    int maxHP;

    float caUpdateInterval;
    float caTimer;

    // === 雲 CA（残像的な雲表現） ===
    vector<vector<int>> cloudCA;     // 小さな残光
    float cloudUpdateInterval;
    float cloudTimer;

    // === ベクトル場（天候による風の向き） ===
    vector<vector<ofVec2f>> flowField;
    float flowTime; // 今回は主にノイズ時間として使用

    // === 天候の周期的切り替え（テスト用） ===
    float weatherChangeTimer;
    float weatherChangeInterval; // 例: 10秒ごとに変更

    // ---------- 内部関数 ----------

    // CA 初期化
    void randomizeCA();

    // 天候 CA の更新（Game of Life + ベクトル場 + 勝者ルール + HP制）
    void updateCA();

    // 雲 CA の更新（シンプルな残像）
    void updateCloudCA();

    // 描画
    void drawCA();
    void drawCloudCA();

    // ベクトル場生成（モデルC：天候方向 + ノイズ揺らぎ）
    void generateFlowFieldForCurrentWeather();

    // （将来用：時間によるベクトル場の変化。今回は中身は空でもOK）
    void updateFlowFieldOverTime();

    // グリッド座標 (gx, gy) に対して、flowField から整数方向 (dx, dy) を得る
    void getFlowDirForCell(int gx, int gy, int& dx, int& dy);
};